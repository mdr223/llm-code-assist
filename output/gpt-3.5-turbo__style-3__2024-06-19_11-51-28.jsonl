{"instance_id": "sqlfluff__sqlfluff-1625", "response": "<patch>\n--- a/.github/PULL_REQUEST_TEMPLATE.md\n+++ b/.github/PULL_REQUEST_TEMPLATE.md\n@@ -6,7 +6,7 @@\n \n ### Brief summary of the change made\n _If there is an open issue for this, then please include `fixes #XXXX` or `closes #XXXX` replacing `XXXX` with the issue number and it will automatically close the issue when the pull request is merged. Alternatively if not fully closed you can say `makes progress on #XXXX` to create a link on that issue without closing it._\n \n-### Are there any other side effects of this change that we should be aware of?\n+### Brief summary of the change made\n ...\n \n ### Pull Request checklist\n@end of/.github/PULL_REQUEST_TEMPLATE.md\n\n--- a/src/sqlfluff/rules/L042.py\n+++ b/src/sqlfluff/rules/L042.py\n@@ -9,9 +9,9 @@\n     \"\"\"Join/From clauses should not contain subqueries. Use CTEs instead.\n \n     By default this rule is configured to allow subqueries within `FROM`\n-    clauses but not within `JOIN` clauses. If you prefer a stricter lint\n+    and `JOIN` clauses. If you prefer a stricter lint\n     then this is configurable.\n \n     NB: Some dialects don't allow CTEs, and for those dialects\n@end of/src/sqlfluff/rules/L042.py\n</patch>", "problem_statement": "L031 desc updated to cover both 'from' and 'join'\n### Brief summary of the change made\r\nSmall update to L031 description so it is clear that it covers both 'from' and 'join' clauses - previously was a bit confusing as it only mentioned 'join' clauses but will also trigger when there is no join present.\r\n\r\nFixes #1624\r\n\r\n\r\n### Are there any other side effects of this change that we should be aware of?\r\nNo\r\n\r\n### Pull Request checklist\r\nAll good", "text_inputs": "You will be provided with a partial code base and an issue statement explaining a problem to resolve.\n<issue>\nL031 desc updated to cover both 'from' and 'join'\n### Brief summary of the change made\r\nSmall update to L031 description so it is clear that it covers both 'from' and 'join' clauses - previously was a bit confusing as it only mentioned 'join' clauses but will also trigger when there is no join present.\r\n\r\nFixes #1624\r\n\r\n\r\n### Are there any other side effects of this change that we should be aware of?\r\nNo\r\n\r\n### Pull Request checklist\r\nAll good\n</issue>\n\n<code>\n\n[start of ./.github/PULL_REQUEST_TEMPLATE.md]\n1 \n2 _Firstly, thanks for adding this feature! Secondly, please check the key steps against the checklist below to make your contribution easy to merge._\n3 \n4 _Please give the Pull Request a meaningful title (including the dialect this PR is for if it is dialect specific), as this will automatically be added to the release notes, and then the Change Log._\n5 \n6 ### Brief summary of the change made\n7 _If there is an open issue for this, then please include `fixes #XXXX` or `closes #XXXX` replacing `XXXX` with the issue number and it will automatically close the issue when the pull request is merged. Alternatively if not fully closed you can say `makes progress on #XXXX` to create a link on that issue without closing it._\n8 ...\n9 \n10 ### Are there any other side effects of this change that we should be aware of?\n11 ...\n12 \n13 ### Pull Request checklist\n14 - [ ] Please confirm you have completed any of the necessary steps below.\n15 \n16 - Included test cases to demonstrate any code changes, which may be one or more of the following:\n17   - `.yml` rule test cases in `test/fixtures/rules/std_rule_cases`.\n18   - `.sql`/`.yml` parser test cases in `test/fixtures/dialects` (note YML files can be auto generated with `python test/generate_parse_fixture_yml.py` or by running `tox` locally).\n19   - Full autofix test cases in `test/fixtures/linter/autofix`.\n20   - Other.\n21 - Added appropriate documentation for the change.\n22 - Created GitHub issues for any relevant followup/future enhancements if appropriate.\n23 \n[end of ./.github/PULL_REQUEST_TEMPLATE.md]\n[start of ./src/sqlfluff/rules/L042.py]\n1 \"\"\"Implementation of Rule L042.\"\"\"\n2 \n3 from sqlfluff.core.rules.base import BaseRule, LintResult\n4 from sqlfluff.core.rules.doc_decorators import document_configuration\n5 \n6 \n7 @document_configuration\n8 class Rule_L042(BaseRule):\n9     \"\"\"Join/From clauses should not contain subqueries. Use CTEs instead.\n10 \n11     By default this rule is configured to allow subqueries within `FROM`\n12     clauses but not within `JOIN` clauses. If you prefer a stricter lint\n13     then this is configurable.\n14 \n15     NB: Some dialects don't allow CTEs, and for those dialects\n16     this rule makes no sense and should be disabled.\n17 \n18     | **Anti-pattern**\n19 \n20     .. code-block:: sql\n21 \n22         select\n23             a.x, a.y, b.z\n24         from a\n25         join (\n26             select x, z from b\n27         ) using(x)\n28 \n29 \n30     | **Best practice**\n31 \n32     .. code-block:: sql\n33 \n34         with c as (\n35             select x, z from b\n36         )\n37         select\n38             a.x, a.y, c.z\n39         from a\n40         join c using(x)\n41 \n42     \"\"\"\n43 \n44     config_keywords = [\"forbid_subquery_in\"]\n45 \n46     _config_mapping = {\n47         \"join\": [\"join_clause\"],\n48         \"from\": [\"from_expression\"],\n49         \"both\": [\"join_clause\", \"from_expression\"],\n50     }\n51 \n52     def _eval(self, segment, **kwargs):\n53         \"\"\"Join/From clauses should not contain subqueries. Use CTEs instead.\n54 \n55         NB: No fix for this routine because it would be very complex to\n56         implement reliably.\n57         \"\"\"\n58         parent_types = self._config_mapping[self.forbid_subquery_in]\n59         for parent_type in parent_types:\n60             if segment.is_type(parent_type):\n61                 # Get the referenced table segment\n62                 from_expression_element = segment.get_child(\"from_expression_element\")\n63                 if not from_expression_element:  # pragma: no cover\n64                     return None  # There isn't one. We're done.\n65                 # Get the main bit\n66                 from_expression_element = from_expression_element.get_child(\n67                     \"table_expression\"\n68                 )\n69                 if not from_expression_element:  # pragma: no cover\n70                     return None  # There isn't one. We're done.\n71                 # Is it bracketed?\n72                 bracketed_expression = from_expression_element.get_child(\"bracketed\")\n73                 # If it is, lint that instead\n74                 if bracketed_expression:\n75                     from_expression_element = bracketed_expression\n76                 # If any of the following are found, raise an issue.\n77                 # If not, we're fine.\n78                 problem_children = [\n79                     \"with_compound_statement\",\n80                     \"set_expression\",\n81                     \"select_statement\",\n82                 ]\n83                 for seg_type in problem_children:\n84                     seg = from_expression_element.get_child(seg_type)\n85                     if seg:\n86                         return LintResult(\n87                             anchor=seg,\n88                             description=f\"{parent_type} clauses should not contain subqueries. Use CTEs instead\",\n89                         )\n90 \n[end of ./src/sqlfluff/rules/L042.py]\n[start of ./test/fixtures/linter/column_references.sql]\n1 select a, b.c, d.g, f as f1, f1 + 1 as f2\n2 from z as a JOIN d using(f) where f2 > 1\n3 -- NB: `f` appears in the USING clause and so shouldn't fail on L027\n4 \n[end of ./test/fixtures/linter/column_references.sql]\n</code>\n\nHere is an example of a patch file. It consists of changes to the code base. It specifies the file names, the line numbers of each change, and the removed and added lines. A single patch file can contain changes to multiple files.\n<patch>\n--- a/file.py\n+++ b/file.py\n@@ -1,27 +1,35 @@\n def euclidean(a, b):\n-    while b:\n-        a, b = b, a % b\n-    return a\n+    if b == 0:\n+        return a\n+    return euclidean(b, a % b)\n \n \n def bresenham(x0, y0, x1, y1):\n     points = []\n     dx = abs(x1 - x0)\n     dy = abs(y1 - y0)\n-    sx = 1 if x0 < x1 else -1\n-    sy = 1 if y0 < y1 else -1\n-    err = dx - dy\n+    x, y = x0, y0\n+    sx = -1 if x0 > x1 else 1\n+    sy = -1 if y0 > y1 else 1\n \n-    while True:\n-        points.append((x0, y0))\n-        if x0 == x1 and y0 == y1:\n-            break\n-        e2 = 2 * err\n-        if e2 > -dy:\n+    if dx > dy:\n+        err = dx / 2.0\n+        while x != x1:\n+            points.append((x, y))\n             err -= dy\n-            x0 += sx\n-        if e2 < dx:\n-            err += dx\n-            y0 += sy\n+            if err < 0:\n+                y += sy\n+                err += dx\n+            x += sx\n+    else:\n+        err = dy / 2.0\n+        while y != y1:\n+            points.append((x, y))\n+            err -= dx\n+            if err < 0:\n+                x += sx\n+                err += dy\n+            y += sy\n \n+    points.append((x, y))\n     return points\n</patch>\n\nI need you to solve the provided issue by generating a single patch file that I can apply directly to this repository using git apply. Please respond with a single patch file in the format shown above.\nRespond below:", "model_patch": "\n--- a/.github/PULL_REQUEST_TEMPLATE.md\n+++ b/.github/PULL_REQUEST_TEMPLATE.md\n@@ -6,7 +6,7 @@\n \n ### Brief summary of the change made\n _If there is an open issue for this, then please include `fixes #XXXX` or `closes #XXXX` replacing `XXXX` with the issue number and it will automatically close the issue when the pull request is merged. Alternatively if not fully closed you can say `makes progress on #XXXX` to create a link on that issue without closing it._\n \n-### Are there any other side effects of this change that we should be aware of?\n+### Brief summary of the change made\n ...\n \n ### Pull Request checklist\n@end of/.github/PULL_REQUEST_TEMPLATE.md\n\n--- a/src/sqlfluff/rules/L042.py\n+++ b/src/sqlfluff/rules/L042.py\n@@ -9,9 +9,9 @@\n     \"\"\"Join/From clauses should not contain subqueries. Use CTEs instead.\n \n     By default this rule is configured to allow subqueries within `FROM`\n-    clauses but not within `JOIN` clauses. If you prefer a stricter lint\n+    and `JOIN` clauses. If you prefer a stricter lint\n     then this is configurable.\n \n     NB: Some dialects don't allow CTEs, and for those dialects\n@end of/src/sqlfluff/rules/L042.py\n", "minimal_patch": "--- a/.github/PULL_REQUEST_TEMPLATE.md\n+++ b/.github/PULL_REQUEST_TEMPLATE.md\n@@ -10,2 +10,2 @@\n-### Are there any other side effects of this change that we should be aware of?\n+### Brief summary of the change made\n ...\n--- a/src/sqlfluff/rules/L042.py\n+++ b/src/sqlfluff/rules/L042.py\n@@ -12,2 +12,2 @@\n-    clauses but not within `JOIN` clauses. If you prefer a stricter lint\n+    and `JOIN` clauses. If you prefer a stricter lint\n     then this is configurable.\n", "model_name_or_path": "gpt-3.5-turbo"}
